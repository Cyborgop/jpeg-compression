# -*- coding: utf-8 -*-
"""JPEG compression_new.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1__bET4cHls6MKn3bRNTy_YdUXQVy5psM
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from PIL import Image

def is_binary_image(image):
    unique_values = np.unique(image)
    return np.array_equal(unique_values, [0, 1]) or np.array_equal(unique_values, [0, 255])

# Load the image using PIL
enter_image_path = input("Enter the image file name: ")
try:
    img = Image.open(enter_image_path)
    print("Image successfully loaded.")
except IOError:
    print("Error: Unable to load the image. Please check the file path and name.")
    exit()

# Convert the PIL image to a numpy array for further processing
img_array = np.array(img)

# Check the range of pixel values
print(f"Pixel range: Min={img_array.min()}, Max={img_array.max()}")
print("Is the image binary?", is_binary_image(img_array))

# Check if the image is grayscale or color
if len(img_array.shape) == 2:  # Grayscale image
    plt.imshow(img_array, cmap='gray', vmin=0, vmax=255)  # Display as grayscale with original contrast
    plt.title('Original grayscale Image')
    plt.axis('off')
    plt.show()

elif len(img_array.shape) == 3 and img_array.shape[2] == 3:  # Color image
    plt.imshow(img_array)
    plt.title('Original color Image (RGB)')
    plt.axis('off')
    plt.show()
else:
    print("Unsupported image format.")

# Function to manually convert RGB to YCbCr
def rgb_to_ycbcr(rgb_img):
    # Conversion matrices (based on YCbCr formula)
    ycbcr_img = np.zeros_like(rgb_img, dtype=float)

    # Define the transformation coefficients
    Y_coef = [0.299, 0.587, 0.114]
    Cb_coef = [-0.168736, -0.331264, 0.5]
    Cr_coef = [0.5, -0.418688, -0.081312]

    # Y channel
    ycbcr_img[:, :, 0] = (Y_coef[0] * rgb_img[:, :, 0] +
                          Y_coef[1] * rgb_img[:, :, 1] +
                          Y_coef[2] * rgb_img[:, :, 2])

    # Cb channel
    ycbcr_img[:, :, 1] = (Cb_coef[0] * rgb_img[:, :, 0] +
                          Cb_coef[1] * rgb_img[:, :, 1] +
                          Cb_coef[2] * rgb_img[:, :, 2]) + 128

    # Cr channel
    ycbcr_img[:, :, 2] = (Cr_coef[0] * rgb_img[:, :, 0] +
                          Cr_coef[1] * rgb_img[:, :, 1] +
                          Cr_coef[2] * rgb_img[:, :, 2]) + 128

    return ycbcr_img

# test
image1 = rgb_to_ycbcr(img_array)
image1_Ycbcr = Image.fromarray(image1.astype(np.uint8))
image1_Ycbcr.save('ycbcr_image.jpg')

def subsampling(ycbcr_img):
    # Extract Y, Cb, and Cr channels
    y_channel = ycbcr_img[:, :, 0]
    cb_channel = ycbcr_img[:, :, 1]
    cr_channel = ycbcr_img[:, :, 2]
    # Medium Compression: Subsample Cb and Cr channels horizontally by 2
    cb_subsampled = cb_channel[:, ::2]
    cr_subsampled = cr_channel[:, ::2]

    # Expand Cb and Cr channels back to match Y channel's shape
    cb_expanded = np.repeat(cb_subsampled, 2, axis=1)
    cr_expanded = np.repeat(cr_subsampled, 2, axis=1)

    # Adjust the shapes to match Y channel's width
    width_difference = cb_expanded.shape[1] - y_channel.shape[1]
    if width_difference > 0:
        cb_expanded = cb_expanded[:, :-width_difference]  # Trim Cb expanded
        cr_expanded = cr_expanded[:, :-width_difference]  # Trim Cr expanded

    return np.stack((y_channel, cb_expanded, cr_expanded), axis=2)
#test
# subsampled_img_aray=subsampling(img_array)
# subsampled_img = Image.fromarray(subsampled_img_aray)
# subsampled_img.save('subsampled_image.jpg')

def pad_image(image, block_size=8):
    """Pads the image to make its dimensions a multiple of the block size."""
    height, width = image.shape
    pad_height = (block_size - height % block_size) % block_size
    pad_width = (block_size - width % block_size) % block_size
    return np.pad(image, ((0, pad_height), (0, pad_width)), mode='constant'), (pad_height, pad_width)

def alpha(u, n):
    # Scaling factor for orthonormal DCT
    return np.sqrt(1/n) if u == 0 else np.sqrt(2/n)

def apply_1d_dct(arr, axis=0):
    n = arr.shape[axis]
    result = np.zeros_like(arr, dtype=np.float32)
    factor = np.pi / (2 * n)

    for u in range(n):
        scaling_factor = alpha(u, n)
        if axis == 0:
            result[u, :] = scaling_factor * np.sum(
                arr * np.cos((2 * np.arange(n).reshape(-1, 1) + 1) * u * factor),
                axis=0
            )
        else:
            result[:, u] = scaling_factor * np.sum(
                arr * np.cos((2 * np.arange(n).reshape(1, -1) + 1) * u * factor),
                axis=1
            )

    return result

def apply_2d_dct(channel):
    # Apply 1D DCT on rows
    dct_rows = apply_1d_dct(channel, axis=0)
    # Apply 1D DCT on columns
    dct_result = apply_1d_dct(dct_rows, axis=1)
    return dct_result

#Test
# image1 = rgb_to_ycbcr(img_array)
# image2 = subsampling(image1)
# y_channel = image2[:, :, 0]
# cb_channel = image2[:, :, 1]
# cr_channel = image2[:, :, 2]
# # Step 2: Pad Y, Cb, and Cr channels
# y_channel_padded, (pad_height_y, pad_width_y) = pad_image(y_channel)
# cb_channel_padded, (pad_height_cb, pad_width_cb) = pad_image(cb_channel)
# cr_channel_padded, (pad_height_cr, pad_width_cr) = pad_image(cr_channel)

# # Step 3: Apply 2D DCT to each subsampled channel separately
# y_dct = apply_2d_dct(y_channel_padded)
# cb_dct = apply_2d_dct(cb_channel_padded)
# cr_dct = apply_2d_dct(cr_channel_padded)
# print("DCT of Y channel:\n", y_dct)
# print("DCT of Cb channel:\n", cb_dct)
# print("DCT of Cr channel:\n", cr_dct)

def quantize_dct(dct_block, quant_matrix):
    """Applies quantization on 8x8 DCT blocks using the quantization matrix."""
    height, width = dct_block.shape
    quantized_block = np.zeros_like(dct_block)
    for i in range(0, height, 8):
        for j in range(0, width, 8):
            # Extract 8x8 block, apply quantization only if it's full-sized
            block = dct_block[i:i + 8, j:j + 8]
            if block.shape == (8, 8):
                quantized_block[i:i + 8, j:j + 8] = np.round(block / quant_matrix).astype(int)
    return quantized_block

# Quantization Matrices
quant_matrix_y = np.array([[16, 11, 10, 16, 24, 40, 51, 61],
                            [12, 12, 14, 19, 26, 58, 60, 55],
                            [14, 13, 16, 24, 40, 57, 69, 56],
                            [14, 17, 22, 29, 51, 87, 80, 62],
                            [18, 22, 37, 56, 68, 109, 103, 77],
                            [24, 35, 55, 64, 81, 104, 113, 92],
                            [49, 64, 78, 87, 103, 121, 120, 101],
                            [72, 92, 95, 98, 112, 100, 103, 99]])

quant_matrix_cb_cr = np.array([[17, 18, 24, 47, 99, 99, 99, 99],
                                [18, 21, 26, 66, 99, 99, 99, 99],
                                [24, 26, 56, 99, 99, 99, 99, 99],
                                [47, 66, 99, 99, 99, 99, 99, 99],
                                [99, 99, 99, 99, 99, 99, 99, 99],
                                [99, 99, 99, 99, 99, 99, 99, 99],
                                [99, 99, 99, 99, 99, 99, 99, 99],
                                [99, 99, 99, 99, 99, 99, 99, 99]])

#Test quantization matrices
image1 = rgb_to_ycbcr(img_array)
image2 = subsampling(image1)
y_channel = image2[:, :, 0]
cb_channel = image2[:, :, 1]
cr_channel = image2[:, :, 2]
# Step 2: Pad Y, Cb, and Cr channels
y_channel_padded, (pad_height_y, pad_width_y) = pad_image(y_channel)
cb_channel_padded, (pad_height_cb, pad_width_cb) = pad_image(cb_channel)
cr_channel_padded, (pad_height_cr, pad_width_cr) = pad_image(cr_channel)

# Step 3: Apply 2D DCT to each subsampled channel separately
y_dct = apply_2d_dct(y_channel_padded)
cb_dct = apply_2d_dct(cb_channel_padded)
cr_dct = apply_2d_dct(cr_channel_padded)
# Quantizing DCT Blocks
quantized_y = quantize_dct(y_dct, quant_matrix_y)
quantized_cb = quantize_dct(cb_dct, quant_matrix_cb_cr)
quantized_cr = quantize_dct(cr_dct, quant_matrix_cb_cr)
print("Quantized DCT of Y channel:\n", quantized_y)
print("Quantized DCT of Cb channel:\n", quantized_cb)
print("Quantized DCT of Cr channel:\n", quantized_cr)

def generate_zigzag(matrix):
    rows, cols = matrix.shape
    result = []

    for s in range(rows + cols - 1):
        if s % 2 == 0:

            for i in range(s, -1, -1):
                if i < rows and s - i < cols:
                    result.append(matrix[i, s - i])
        else:

            for i in range(s + 1):
                if i < rows and s - i < cols:
                    result.append(matrix[i, s - i])

    return result

# test
test_matrix = np.array([
    [1, 2, 3],
    [4,5, 6],
    [7,8,9]

])

zigzag_result = generate_zigzag(test_matrix)
print("Zigzag Order:", zigzag_result)

# Huffman code table for (run-length, size)
huffman_table = {
    (0, 0): "1010",
    (0, 1): "00",
    (0, 2): "01",
    (0, 3): "100",
    (0, 4): "1011",
    (0, 5): "11010",
    (0, 6): "111100",
    (1, 1): "110",
    (1, 2): "1110",
    (1, 3): "111110",
    (2, 1): "11110",
    (2, 2): "1111110",
    (3, 1): "11111110",
    (3, 2): "111111110",
    (4, 1): "1111111110",
    (5, 1): "11111111110",
}

def run_length_encode(ac_coefficients):

    encoded_output = []
    huffman_encoded = []
    zero_run = 0  # Counter for consecutive zeros

    for coeff in ac_coefficients:
        coeff = int(coeff)  # Convert numpy int64 to native Python int

        if coeff == 0:
            zero_run += 1  # Increment zero run length if coefficient is zero
        else:
            # Get the size category of the non-zero coefficient
            size = coeff.bit_length() if coeff > 0 else (-coeff).bit_length()
            encoded_output.append((zero_run, size, coeff))  # Append (run-length, size, value)

            # Look up Huffman code for (run-length, size)
            if (zero_run, size) in huffman_table:
                huffman_encoded.append(huffman_table[(zero_run, size)])
            else:
                huffman_encoded.append("undefined")  # Placeholder for missing Huffman codes

            zero_run = 0  # Reset zero run length after encoding non-zero coefficient

    # End of Block (EOB) for trailing zeros
    if zero_run > 0:
        encoded_output.append((0, 0))  # EOB marker
        huffman_encoded.append(huffman_table.get((0, 0), "undefined"))

    return encoded_output, huffman_encoded

#Main Function
image1 = rgb_to_ycbcr(img_array)
image2 = subsampling(image1)
# Step 1: Extract Y, Cb, and Cr channels from the subsampled image
y_channel = image2[:, :, 0]
cb_channel = image2[:, :, 1]
cr_channel = image2[:, :, 2]

# Step 2: Pad Y, Cb, and Cr channels
y_channel_padded, (pad_height_y, pad_width_y) = pad_image(y_channel)
cb_channel_padded, (pad_height_cb, pad_width_cb) = pad_image(cb_channel)
cr_channel_padded, (pad_height_cr, pad_width_cr) = pad_image(cr_channel)

# Step 3: Apply 2D DCT to each subsampled channel separately
y_dct = apply_2d_dct(y_channel_padded)
cb_dct = apply_2d_dct(cb_channel_padded)
cr_dct = apply_2d_dct(cr_channel_padded)

# Quantizing DCT Blocks
quantized_y = quantize_dct(y_dct, quant_matrix_y)
quantized_cb = quantize_dct(cb_dct, quant_matrix_cb_cr)
quantized_cr = quantize_dct(cr_dct, quant_matrix_cb_cr)

# Step 5: Stack the DCT-transformed channels back into a single image
# quantized_image = np.stack((quantized_y, quantized_cb, quantized_cr), axis=2)

#Step 6: generate zigzag matrix for each channel
zigzag_y = generate_zigzag(quantized_y)
zigzag_cb = generate_zigzag(quantized_cb)
zigzag_cr = generate_zigzag(quantized_cr)

#Step 6: Generate run length encoding for each zigzag
encoded_y, huffman_y = run_length_encode(zigzag_y)
encoded_cb, huffman_cb = run_length_encode(zigzag_cb)
encoded_cr, huffman_cr = run_length_encode(zigzag_cr)

original_data_size = img_array.size * 8  # Assuming 8 bits per channel for original RGB image

# Calculate compressed data size in bits
compressed_data_size_y = sum(len(code) for code in huffman_y)
compressed_data_size_cb = sum(len(code) for code in huffman_cb)
compressed_data_size_cr = sum(len(code) for code in huffman_cr)

total_compressed_data_size = compressed_data_size_y + compressed_data_size_cb + compressed_data_size_cr

# Calculate compression ratio
compression_ratio = original_data_size / total_compressed_data_size if total_compressed_data_size != 0 else 0

# Test for Y Channel
print("Y Channel - Run-Length Encoded:")
for entry, code in zip(encoded_y, huffman_y):
    if len(entry) == 3:
        run, size, value = entry
        print(f"Run-Length: ({run}, {size}), Value: {value}, Huffman Code: {code}")
    else:
        print(f"End of Block (EOB) detected, Huffman Code: {code}")

# Print Run-Length Encoding and Huffman Codes for Cb Channel
print("\nCb Channel - Run-Length Encoded:")
for entry, code in zip(encoded_cb, huffman_cb):
    if len(entry) == 3:
        run, size, value = entry
        print(f"Run-Length: ({run}, {size}), Value: {value}, Huffman Code: {code}")
    else:
        print(f"End of Block (EOB) detected, Huffman Code: {code}")

# Print Run-Length Encoding and Huffman Codes for Cr Channel
print("\nCr Channel - Run-Length Encoded:")
for entry, code in zip(encoded_cr, huffman_cr):
    if len(entry) == 3:
        run, size, value = entry
        print(f"Run-Length: ({run}, {size}), Value: {value}, Huffman Code: {code}")
    else:
        print(f"End of Block (EOB) detected, Huffman Code: {code}")

# Print Compression Ratio
print(f"\nOriginal Data Size (bits): {original_data_size}")
print(f"Compressed Data Size (bits): {total_compressed_data_size}")
print(f"Compression Ratio: {compression_ratio:.2f}")

import json

def save_compressed_data(encoded_y, huffman_y, encoded_cb, huffman_cb, encoded_cr, huffman_cr, filename="compressed_image_data.json"):
    """
    Saves the compressed image data, including run-length encoding and Huffman codes, to a file.

    Parameters:
        encoded_y (list): Run-length encoded data for the Y channel.
        huffman_y (list): Huffman codes for the Y channel.
        encoded_cb (list): Run-length encoded data for the Cb channel.
        huffman_cb (list): Huffman codes for the Cb channel.
        encoded_cr (list): Run-length encoded data for the Cr channel.
        huffman_cr (list): Huffman codes for the Cr channel.
        filename (str): Name of the file to save the compressed data.
    """

    # Structure the data for saving
    compressed_data = {
        "Y_channel": {
            "run_length_encoding": encoded_y,
            "huffman_codes": huffman_y
        },
        "Cb_channel": {
            "run_length_encoding": encoded_cb,
            "huffman_codes": huffman_cb
        },
        "Cr_channel": {
            "run_length_encoding": encoded_cr,
            "huffman_codes": huffman_cr
        }
    }

    # Save data to a JSON file
    with open(filename, 'w') as file:
        json.dump(compressed_data, file, indent=4)

    print(f"Compressed data saved to {filename}")

# Example usage in the main function
save_compressed_data(encoded_y, huffman_y, encoded_cb, huffman_cb, encoded_cr, huffman_cr)