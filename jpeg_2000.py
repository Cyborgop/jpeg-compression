# -*- coding: utf-8 -*-
"""JPEG 2000.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bbbb2D_5ZbAGzPCkn37bNAkHqNE2IJHo

HAAR 1D
"""

import numpy as np

def haar_lift_1d(x):
    n = len(x)
    assert n % 2 == 0

    s = np.zeros(n // 2, dtype=int)
    d = np.zeros(n // 2, dtype=int)

    for i in range(0, n, 2):
        d[i//2] = x[i+1] - x[i]
        s[i//2] = x[i] + (d[i//2] >> 1)

    return s, d


def haar_ilift_1d(s, d):
    n = len(s) * 2
    x = np.zeros(n, dtype=int)

    for i in range(len(s)):
        x[2*i]   = s[i] - (d[i] >> 1)
        x[2*i+1] = x[2*i] + d[i]

    return x

"""HAAR 2D"""

def haar_lift_2d(img):
    h, w = img.shape
    assert h % 2 == 0 and w % 2 == 0, "Image dimensions must be even"

    h2, w2 = h // 2, w // 2
    temp = np.zeros_like(img, dtype=int)

    # ---- Row transform ----
    for i in range(h):
        s, d = haar_lift_1d(img[i])
        temp[i, :w2] = s
        temp[i, w2:] = d

    out = np.zeros_like(img, dtype=int)

    # ---- Column transform ----
    for j in range(w):
        s, d = haar_lift_1d(temp[:, j])
        out[:h2, j] = s
        out[h2:, j] = d

    return out

"""BIT PLANE (EBCOT STYLE ALGORITHM)"""

import numpy as np

def bitplane_encode(coeffs):
    coeffs = coeffs.astype(int)
    flat = coeffs.flatten()

    max_val = np.max(np.abs(flat))
    if max_val == 0:
        return [], 0

    maxbit = int(np.floor(np.log2(max_val)))
    stream = []

    for b in range(maxbit, -1, -1):
        mask = 1 << b
        for v in flat:
            stream.append(1 if (abs(v) & mask) else 0)

    return stream, maxbit

class ArithmeticEncoder:
    def __init__(self):
        self.low = 0.0
        self.high = 1.0
        self.out = []

    def encode_bit(self, bit, p1):
        mid = self.low + (self.high - self.low) * (1 - p1)
        if bit == 1:
            self.low = mid
        else:
            self.high = mid
        if self.high - self.low < 1e-6:
            self.out.append((self.low + self.high) / 2)
            self.low, self.high = 0.0, 1.0

    def finish(self):
        self.out.append((self.low + self.high) / 2)
        return self.out

class ArithmeticDecoder:
    def __init__(self, code):
        self.code = code
        self.low = 0.0
        self.high = 1.0
        self.idx = 0
        self.value = code[0]

    def decode_bit(self, p1):
        mid = self.low + (self.high - self.low) * (1 - p1)
        if self.value >= mid:
            bit = 1
            self.low = mid
        else:
            bit = 0
            self.high = mid
        if self.high - self.low < 1e-6:
            self.idx += 1
            if self.idx < len(self.code):
                self.value = self.code[self.idx]
            self.low, self.high = 0.0, 1.0
        return bit

def ebcot_encode(bitstream, p1=0.05):
    enc = ArithmeticEncoder()
    for b in bitstream:
        enc.encode_bit(b, p1)
    return enc.finish()

def ebcot_decode(code, nbits, p1=0.05):
    dec = ArithmeticDecoder(code)
    return [dec.decode_bit(p1) for _ in range(nbits)]

def rate_control(code, target_bytes):
    return code[:target_bytes // 8]

# ---------- RUN ----------
img = imageio.imread("/content/cat.jpg")
if img.ndim == 3:
    img = img.mean(axis=2)
img = img.astype(int)

h, w = img.shape
img = img[:h - h % 2, :w - w % 2]

coeffs = haar_lift_2d(img)
stream, maxbit = bitplane_encode(coeffs)
arith_code = ebcot_encode(stream)
compressed = rate_control(arith_code, target_bytes=40 * 1024)

print("Original pixels:", img.size)
print("Bitstream bits:", len(stream))
print("Compressed symbols:", len(compressed))

import imageio.v2 as imageio
import numpy as np

img = imageio.imread("/content/cat.jpg")

# convert RGB â†’ grayscale if needed
if img.ndim == 3:
    img = img.mean(axis=2)

img = img.astype(int)

# ensure even dimensions
h, w = img.shape
img = img[:h - h % 2, :w - w % 2]

# Wavelet transform
coeffs = haar_lift_2d(img)

# Bit-plane encode
stream, maxbit = bitplane_encode(coeffs)

print("Compressed bitstream length:", len(stream))

"""EBCOT STYLE CODER"""

# Decode only top bits (progressive)
partial_stream = stream[:len(stream)//4]

decoded_coeffs = bitplane_decode(
    partial_stream + [0]*(len(stream)-len(partial_stream)),
    coeffs.shape,
    maxbit
)